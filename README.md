# test
Exp 1 (Blinking LED using STM32 Nucleo Board)
• STM32 Nucleo-F103RB Development Board
• USB cable (for programming and powering the board)
• STM32CubeIDE software
Board Selector, type STM32 Nucleo-F103RB
while(1){
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, 1);
  Delay_ms(1000);
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, 0);
  Delay_ms(1000);
}
-------------------------------------------------------------------------------------
Exp 2(LED BLINKING)
Proteus 8 + MicroC for PIC
Blinking of a LED light:
void main() {
  TRISB = 0x00;
  PORTB = 0x00;
  while(1) {
    PORTB = 0b00000001;
    Delay_ms(250);
    PORTB = 0b00000000;
    Delay_ms(250);
    }
}
Blinking of 8 LED sequence using loop:
void main() {
  TRISB = 0x00;
  PORTB = 0x00;
  while(1) {
      unsigned int x=0;
      for(x=0;x<8;x++) {PORTB=(1<<x);
      delay_ms(100);
  }
}
6 to 13->resistor 220 ohm then to leds and led to ground
---------------------------------------------------------------------------------------------
Exp-3 (7 Segment Display)
Components / Tools Required:
16*2 LCD Display and 7 segment display
Code:
void main() {
  TRISB = 0x00; // Set PORTB as output
  PORTB = 0x00; // Initialize PORTB
  while(1)
  {
    PORTB = 0b00111111; // For number 1
    delay_ms(500); //Delay of 500ms
    PORTB = 0b00000110; //For number 2
    delay_ms(500); //Delay of 500ms
    PORTB = 0b01101111; // For number 3
    delay_ms(500); //Delay of 500ms
    PORTB = 0b01001111; // For number 4
    delay_ms(500); //Delay of 500ms
    PORTB = 0b01100110; // For number 5
    delay_ms(500); // Delay of 500ms
    PORTB = 0b01101101; // For number 6
    delay_ms(500); // Delay of 500ms
    PORTB = 0b01111101; // For number 7
    delay_ms(500); // Delay of 500ms
    PORTB = 0b00000111; // For number 8
    delay_ms(500); // Delay of 500ms
    PORTB = 0b01111111; // For number 9

    delay_ms(500); // Delay of 500ms
    PORTB = 0b01101111; // For number 0
    delay_ms(500); // Delay of 500ms
  } 
}
}
6 to 12 pin to 220 and then 7 segment led
----------------------------------------------------------------------------------------------------
Exp 4 (Stepper Motor)
MicroC PIC16F84A (Microcontroller), ULN2003A(Driver), Stepper Motor
Theory: This circuit is a stepper motor control system using a PIC16F84Amicrocontroller
and a ULN2003A driver IC. The PIC16F84A is an 8-bit microcontroller that provides digital
outputs to control external devices. In this circuit, it is used to generate the required sequence
of pulses to drive a stepper motor.
Stepper motors require a specific sequence of energizing their coils to rotate in steps, and the
microcontroller handles this logic.
Since the PIC’s I/O pins cannot directly drive the higher current needed by the motor, a
ULN2003A driver IC is used. The ULN2003A is a Darlington transistor array that works as a
current amplifier, allowing low-power signals from the microcontroller to control
higher-power loads like motors.
1 The RB0–RB3 pins of the PIC are connected to the inputs of the ULN2003A (pins 1B–4B).
2 The corresponding outputs (1C–4C) of the ULN2003A are connected to the stepper motor
windings.
3 The COM pin of ULN2003A is tied to the motor’s supply voltage to handle the back EMF
generated by the coils.
When the microcontroller sends a logic HIGH on one of its output pins, the ULN2003A sinks
current through the motor winding, energizing it. By sending a proper sequence of signals
(full-step, half-step, or wave drive), the motor shaft rotates step by step.
Code:
void main() {
  TRISB = 0x00; // Set PORTB as output
  PORTB = 0x00; // Initialize PORTB
  while(1) {
    PORTB = 0b0001; // For sequence 0001
    Delay_ms(200); // Delay of 200 ms
    PORTB = 0b0010; // For sequence 0010
    Delay_ms(200); // Delay of 200 ms

    PORTB = 0b0100; // For sequence 0100
    Delay_ms(200); // Delay of 200 ms
    PORTB = 0b1000; // For sequence 1000
    Delay_ms(200); // Delay of 200 ms
  }
}
PIC1684A-6 to 9--->ULN2003A 1 to 4--->then ULN2003A com to 4c to stepper motor--->gnd
----------------------------------------------------------------------------------------------
# Keypad press code

unsigned short KP = 0;
char keypadPort at PORTB ;
 void main () {
 TRISA = 0 x00 ;
 PORTA = 0 x00 ;
 Keypad_Init () ;

 while (1) {
     do {
     KP = Keypad_Key_Press () ;
     } while (! KP ) ;
    
     if (( KP <= 3) ) {
     PORTA = KP ;
     }
     else if (( KP > 3) && ( KP <= 7) ) {
     PORTA = KP - 1;
     }
     else if (( KP > 7) && ( KP <= 11) ) {
    PORTA = KP - 2;
    }
 }
}
PIC16F877A 2to 5->7,1,2,6 of 74ls47 and RB0 to RB3 of pic to 1 to 3 of keypad RB4 to Rb7 to A to D of keypad then 74ls47 all outputs to all display inputs,
------------------------------------------------------------------------------------------------------
experiment 5 : UART 
Tx -> Rx 
Rx -> Tx 
Gnd -> Gnd

Transmitter 
```c
void setup() {
  Serial.begin(9600);
}
void loop() {
  Serial.println("Hello from A");
  delay(1000);
}

```
Reciever
```C
void setup() {
  Serial.begin(9600);
}
void loop() {
  if (Serial.available()) {
    Serial.println(Serial.readString());
  }
}
```
--------------------------------------------------------------------------------
## SPI
|SPI Signal|Master (Board A)|Slave (Board B)|
|---|---|---|
|MOSI|11|11|
|MISO|12|12|
|SCK|13|13|
|SS|10|10|
|GND|GND|GND|
Master
```C
#include <SPI.h>
void setup() {
  SPI.begin();
  pinMode(10, OUTPUT);
}
void loop() {
  digitalWrite(10, LOW);
  SPI.transfer('A');
  digitalWrite(10, HIGH);
  delay(1000);
}

```
Slave
```C
#include <SPI.h>
volatile byte data;
void setup() {
  SPI.begin();
  SPCR |= _BV(SPE);
  pinMode(MISO, OUTPUT);
  SPI.attachInterrupt();
  Serial.begin(9600);
}
ISR(SPI_STC_vect) {
  data = SPDR;
}
void loop() {
  if (data) {
    Serial.println((char)data);
    data = 0;
  }
}

```
------------------------------------------------------------------------
## I2C
|Signal|Master (Board A)|Slave (Board B)|
|---|---|---|
|SDA|A4|A4|
|SCL|A5|A5|
|GND|GND|GND|

Master
```C
#include <Wire.h>

void setup() {
  Wire.begin(); 
  Serial.begin(9600);
  Serial.println("I2C Master Ready");
}

void loop() {
  Wire.beginTransmission(0x08);
  Wire.write("Hello");         
  Wire.endTransmission();      
  Serial.println("Data sent to slave");
  delay(1000);
}
```

Slave
```C
#include <Wire.h>
#include <Wire.h>

void setup() {
  Wire.begin(0x08);
  Wire.onReceive(receiveEvent); 
  Serial.begin(9600);
  Serial.println("I2C Slave Ready");
}

void loop() {
  delay(100);
}

void receiveEvent(int howMany) {
  while (Wire.available()) {
    char c = Wire.read(); 
    Serial.print(c);
  }
  Serial.println();
}

```
-----------------------------------------------------------------------------------
## USB
only on 1 arduino
```C
void setup() {
  Serial.begin(9600);         // start USB serial at 9600 baud
  Serial.println("Hello PC via USB!");
}

void loop() {
  Serial.println(millis());   // print uptime every second
  delay(1000);
}
```
--------------------------------------------------------------------------------------
1. UART Bitstream Demo

Transmitter (UART_TX.ino)

void setup() { Serial.begin(9600); }
void loop() {
  byte seq[] = {B10101, B1001101};
  byte len[] = {5, 7};
  for (byte i = 0; i < 2; i++) {
    Serial.write(len[i]);
    Serial.write(seq[i]);
    Serial.print("TX UART Bits: ");
    for (byte b = 0; b < len[i]; b++) Serial.print((seq[i] >> b) & 1);
    Serial.println();
    delay(500);
  }
  delay(2000);
}


Receiver (UART_RX.ino)

void setup() {
  Serial.begin(9600);
  Serial.println("Start\tB0\tB1\tB2\tB3\tB4\tB5\tB6\tB7\tParity\tStop");
}
void loop() {
  if (Serial.available() >= 2) {
    byte len = Serial.read(), data = Serial.read(), p = 0, bits[9];
    for (byte i = 0; i < len; i++) p ^= bits[i] = (data >> i) & 1;
    Serial.print("RX UART Bits: ");
    for (byte i = 0; i < len; i++) Serial.print(bits[i]);
    Serial.print(" | Parity: "); Serial.println(p);
    Serial.print(0); Serial.print('\t');
    for (byte i = 0; i < 8; i++) { Serial.print(i < len ? bits[i] : 0); Serial.print('\t'); }
    Serial.print(p); Serial.print('\t'); Serial.println(1);
  }
}
--------------------------------------------------------------------------------------------------------------------------------------
2. SPI Bitstream Demo

Transmitter (SPI_TX.ino)

#include <SPI.h>
void setup() {
  SPI.begin();
  Serial.begin(9600);
  byte seq[] = {B10101, B1001101};
  for (byte i = 0; i < 2; i++) {
    SPI.transfer(seq[i]);
    Serial.print("TX SPI Bits: ");
    for (int b = 7; b >= 0; b--) Serial.print((seq[i] >> b) & 1);
    Serial.println();
    delay(500);
  }
}
void loop() {}


Receiver (SPI_RX.ino)
(Simulated via SPI interrupt — prints bits received)

#include <SPI.h>
volatile byte val = 0, flag = 0;
ISR(SPI_STC_vect) { val = SPDR; flag = 1; }
void setup() {
  Serial.begin(9600);
  pinMode(MISO, OUTPUT);
  SPCR |= _BV(SPE);
  SPI.attachInterrupt();
}
void loop() {
  if (flag) {
    Serial.print("RX SPI Bits: ");
    for (int b = 7; b >= 0; b--) Serial.print((val >> b) & 1);
    Serial.println();
    flag = 0;
  }
}

-------------------------------------------------------------------------------------------------------------------------
3. I²C Bitstream Demo

Transmitter (I2C_Master.ino)

#include <Wire.h>
void setup() {
  Wire.begin();
  Serial.begin(9600);
  byte seq[] = {B10101, B1001101};
  for (byte i = 0; i < 2; i++) {
    Wire.beginTransmission(8);
    Wire.write(seq[i]);
    Wire.endTransmission();
    Serial.print("TX I2C Bits: ");
    for (int b = 7; b >= 0; b--) Serial.print((seq[i] >> b) & 1);
    Serial.println();
    delay(500);
  }
}
void loop() {}


Receiver (I2C_Slave.ino)

#include <Wire.h>
void recv(int n) {
  while (Wire.available()) {
    byte val = Wire.read();
    Serial.print("RX I2C Bits: ");
    for (int b = 7; b >= 0; b--) Serial.print((val >> b) & 1);
    Serial.println();
  }
}
void setup() {
  Serial.begin(9600);
  Wire.begin(8);
  Wire.onReceive(recv);
}
void loop() {}

-----------------------------------------------------------------------------------------------------------------
4. USB (Serial via CDC) Bitstream Demo

Transmitter (USB_TX.ino)

void setup() { Serial.begin(9600); }
void loop() {
  byte val = B1010110;
  Serial.write(val);
  Serial.print("TX USB Bits: ");
  for (int b = 7; b >= 0; b--) Serial.print((val >> b) & 1);
  Serial.println();
  delay(1000);
}
----------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------

## FIR
**FIR (Finite Impulse Response)**
- Output depends _only_ on current and past input samples.
- Always stable.
- Uses **no feedback**
- Easy to design, predictable, but can need more coefficients.
**IIR (Infinite Impulse Response)**
- Output depends on both input and _previous outputs_.
- Uses **feedback**, so it’s more efficient (fewer coefficients) but can go unstable if you mess up.

FIR
```C
#define N 3
float x[N];
float coeffs[N] = {1.0/N, 1.0/N, 1.0/N};

float fir(float newSample) {
  for (int i = N - 1; i > 0; i--) x[i] = x[i - 1];
  x[0] = newSample;
  float y = 0;
  for (int i = 0; i < N; i++) y += coeffs[i] * x[i];
  return y;
}

void setup() {
  Serial.begin(9600);
}

void loop() {
  static int n = 0;
  float t = n * 0.1;                        // fake time
  float input = sin(t) * 100 + random(-10, 10);  // noisy sine wave
  float output = fir(input);

  Serial.print(input); Serial.print(","); Serial.println(output); // for plotting
  n++;
  delay(50);
}


```

IIR
```C
float alpha = 0.1; // 0 < alpha < 1  (smaller = smoother)
float y = 0;

void setup() {
  Serial.begin(9600);
}

void loop() {
  static int n = 0;
  float t = n * 0.1;
  float input = sin(t) * 100 + random(-10, 10);  // noisy sine
  y = y + alpha * (input - y);                   // IIR filter
  Serial.print(input); Serial.print(","); Serial.println(y);
  n++;
  delay(50);
}


--------------------------------------------------------------------------------------
TA FIR IIR 


//IIR filter
float xn1=0;
float yn1=0;
const int analoginputpin=A0;


void setup() {
  serial.begin(9600);
  // put your setup code here, to run once:

}

void loop() {
  // put your main code here, to run repeatedly:
   float t=micros()/1.0e6;
   float xn=sin(2*2*PI*t)+0.2*sin(2*50*PI*t);
   float yn=0.959*yn1+0.0155*xn1+0.0155*xn;
   float max_xn=1.2;
   xn=/max_xn;
   serial.print(xn);
   serial.print(" ");
   serial.print(yn);
   xn1=xn;
   yn1=yn;
   delay(1);
}



// FIR filter (fixed & initialized)
const int N = 2;
float buffer_xn[N];
float b[N] = {0.0155, 0.0155}; // example coefficients

void setup() {
  Serial.begin(9600);
  // initialize buffer to zero
  for (int i = 0; i < N; i++) buffer_xn[i] = 0.0;
}

void loop() {
  float t = micros() / 1.0e6;
  // test input: 2 Hz component and 50 Hz small noise
  float xn = sin(2.0 * 4.0 * PI * t) + 0.2 * sin(2.0 * 50.0 * PI * t);
  xn = xn / 1.2; // normalization of input

  // shift buffer: oldest sample goes to highest index
  for (int i = N - 1; i > 0; i--) {
    buffer_xn[i] = buffer_xn[i - 1];
  }
  buffer_xn[0] = xn; // newest sample at index 0

  // convolution: y[n] = sum_{k=0}^{N-1} b[k] * x[n-k]
  float yn = 0.0;
  for (int i = 0; i < N; i++) {
    yn += b[i] * buffer_xn[i];
  }

  // Optional: normalize to unity DC gain
  // float gain = 0.0; for (int i=0;i<N;i++) gain += b[i];
  // if (gain != 0.0) yn /= gain;

  // Print input and output for Serial Plotter
  Serial.print(xn);
  Serial.print(" ");
  Serial.println(yn);

  delay(1);
}

--------------------------------------------------------------------------------------------------

 
